/* 	File:		afpDataStream.h  	Contains:	Public Header file for the low level AppleShare Client API (AFP Protocol)  	Version:	3.8.5 */#ifndef __AFPDATASTREAM__#define __AFPDATASTREAM__#ifndef __CONDITIONALMACROS__#include <ConditionalMacros.h>#endif#ifndef __MIXEDMODE__#include <MixedMode.h>#endif#ifndef __DEVICES__#include <Devices.h>#endif#ifndef __APPLETALK__//#include <AppleTalk.h>#endif#ifndef __OPENTRANSPORT__#include <OpenTransport.h>#endif#ifndef __OPENTPTINTERNET__//#include <OpenTptInternet.h>#endif#ifndef __OPENTPTAPPLETALK__//#include <OpenTptAppleTalk.h>#endif#if PRAGMA_ONCE#pragma once#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_IMPORT#pragma import on#endif#if PRAGMA_STRUCT_ALIGN	#pragma options align=mac68k#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(push, 2)#elif PRAGMA_STRUCT_PACK	#pragma pack(2)#endif/*	-------------------------------------------------------------------------	csCodes	------------------------------------------------------------------------- *//* for PBControl calls*/enum {	afpGetAttnRoutine			= 252,							/*	Get the default AFP Attention routine*/	dsOpenSession				= 244,							/*	Open an AFP session to the server*/	dsGetStatus					= 243,							/*	Send a GetSrvrInfo request to the server*/	dsSendRequest				= 240,							/*	Send an AFP command to the server*/	dsCloseSession				= 237,							/*	Close the specified session*/	dsCloseAll					= 232,							/*	Close all sessions*/	dsIOCTL						= 231,							/*	Make an IOCTL call to the session endpoint iff it is TCP/IP*/																/* these will be retired soon	*/	AFPInsSessMemBlk			= 246,							/* insert the SMB into the drviers Queue	*/	AFPRemSessMemBlk			= 245							/* remove the SMB from the drviers Queue	*/};/* for PBStatus calls*/enum {	afpGetFSID					= 127,							/*	returns the File System ID	*/	afpSVolInfo					= 124,							/* 	returns basic info about the server volume (address, servername, username...)*/	afpXGetVolInfo				= 121,							/*	returns extended info about the volume (server time offset, volume grade...)*/	afpGetSMBSize				= 118,							/*  returns the size of the session memory block required for a new session*/	dsGetXPortInfo				= 236							/*	returns information about the transport used for the given session*/};/*	-------------------------------------------------------------------------	Data Stream Parameter Block	------------------------------------------------------------------------- */typedef CALLBACK_API( void , DSIOCompletionProcPtr )(void *pb);/*	WARNING: DSIOCompletionProcPtr uses register based parameters under classic 68k			 and cannot be written in a high-level language without 			 the help of mixed mode or assembly glue.*/typedef REGISTER_UPP_TYPE(DSIOCompletionProcPtr) 				DSIOCompletionUPP;/* csCode = dsSendRequest*/struct DSWritePB {	UInt32 							dsWriteDataOffset;			/* <- specifies the write offset in the data*/	UInt32 							dsWriteBufferSize;			/* <- size of the data to be written*/	Byte *							dsWriteBuffer;				/* <- ptr to data to be written*/};typedef struct DSWritePB				DSWritePB;/* csCode = dsGetStatus*/struct DSGetStatusPB {	OTAddress *						dsGSSrvrAddress;			/* <- OT Address of server to GetStatus() from (you also need to fill in the reply buffer & size)*/	const char *					dsGSEpString;				/* <- endpoint string for the connection (nil == default)		*/};typedef struct DSGetStatusPB			DSGetStatusPB;/* NOTE: 	Make sure the reply buffer for the dsGetStatus call is at least 2048 bytes, 	it may be advisable to make it larger in the future.	*//* csCode = dsOpenSession*/struct DSOpenPB {	AttnRoutineUPP 					dsOSAttnRoutine;			/* <- Custom attention routine (nil == default)*/	OTAddress *						dsOSSrvrAddress;			/* <- OT Address of server to open a session to*/	Ptr 							dsOSSessionBlock;			/* <- ptr to the SMB; memory reserved for the session.*/	const char *					dsOSEpString;				/* <- endpoint string for the connection (nil == default)		*/};typedef struct DSOpenPB					DSOpenPB;enum {	SMBSize						= 3072							/* size of the session memory block (must be allocated in the System Heap)*/};/*	NOTE:	you should use the afpGetSMBSize call instead of this constant.*/struct DSParamBlock {	QElem *							qLink;						/* - standard header stuff*/	short 							qType;						/* - standard header stuff*/	short 							ioTrap;						/* - standard header stuff*/	Ptr 							ioCmdAddr;					/* - standard header stuff*/	DSIOCompletionUPP 				ioCompletion;				/* <- completion rtn point*/	OSErr 							ioResult;					/* -> result from Async call*/	long 							cmdResult;					/* -> result from the Server for the AFP Cmd*/	short 							ioVRefNum;					/* - standard header stuff */	short 							ioCRefNum;					/* <- RefNum of the ".AFPTranslator"*/	short 							csCode;						/* <- DS Command code*/	short 							dsTimeout;					/* <- ASP - How long to wait before retrying request, TCP - resv for internal use*/	short 							dsReserved1;				/* -  resv for internal use*/	long 							dsRetry;					/* <- ASP - How many times to retry the request, TCP - unused*/	UInt16 							dsReserved2;				/* -  resv for internal use*/	short 							dsSessRefNum;				/* <- AFP Session number*/	short 							dsReserved3;				/* -  resv for internal use*/	short 							dsCmdBufferSize;			/* <- size of the command buffer*/	UInt8 *							dsCmdBuffer;				/* <- ptr to the command buffer*/	UInt32 							dsReplyBufferSize;			/* <- size of the reply buffer*/	UInt8 *							dsReplyBuffer;				/* <- ptr to the reply buffer*/	union {		DSOpenPB 						open;		DSWritePB 						write;		DSGetStatusPB 					status;	} 								csParam;};typedef struct DSParamBlock				DSParamBlock;typedef DSParamBlock *					DSParamBlockPtr;/* NOTE:	The dsCmdBuffer for the csCode = dsOpenSession case Must contain an AFP Login command.	The dsCmdBuffer for the csCode = dsCloseSession case Must contain an AFP Logout command.	Consult Inside AppleTalk for the packet formats.*/struct DSXPortInfo {	long 							dsXPortType;				/* Transport Type (kASPXport, kTCPXport)*/	short 							dsXPortSessRefNum;			/* Session ref number for ASP or TCP*/	union {		InetAddress 					ipAddr;		DDPAddress 						ddpAddr;	} 								addr;};typedef struct DSXPortInfo				DSXPortInfo;typedef DSXPortInfo *					DSXPortInfoPtr;/* definitions for 	dsXPortType */enum {	kASPXport					= 0x00,	kTCPXport					= 0x01};/* argument structure for the dsIOCTL call, put a pointer to the DSIOCTLArgs    struct into the dsCmdBuffer field & fill out the dsCmdBufferSize with   sizeof(DSIOCTLArgs). put the session refnum of the session   you are interested in, into dsSessRefNum. The result of the IOCTL   call will be in the cmdResult field. if the session is not a TCP/IP   session you will recieve an error (ENOTSOCK)*/struct DSIOCTLArgs {	UInt32 							ioctlCmd;	void *							ioctlData;};typedef struct DSIOCTLArgs				DSIOCTLArgs;typedef DSIOCTLArgs *					DSIOCTLArgsPtr;struct GetVolSessInfoRec {	short 							sessAFPVersion;				/*	AFP version number: */	short 							sessReferenceNumber;		/*	AFP session reference number*/	short 							sessAFPVolID;				/*	AFP volume identifier*/	OTAddress *						sessServerAddress;			/*	server internet address*/	short 							sessUAMType;				/*	user authentication method*/	StringPtr 						sessUserNamePtr;			/*	ptr to user name string*/	Ptr 							sessVolIconPtr;				/*	ptr to server volume icon/mask*/	StringPtr 						sessWhereStringPtr;			/*	ptr to "where" information string, shown in the Get Info window*/};typedef struct GetVolSessInfoRec		GetVolSessInfoRec;typedef GetVolSessInfoRec *				GetVolSessInfoRecPtr;enum {	kAFPVersion11				= 1,	kAFPVersion20				= 2,	kAFPVersion21				= 3,	kAFPVersion22				= 4,	kAFPVersion23				= 5};enum {	kNoUserAuth					= 1,							/*	'No User Authent' UAM (Guest)*/	kCleartextAuth				= 2,							/*	'Cleartxt Passwrd' UAM 	(types 2 & 3 will be automatically upgraded to 6 if avail.)*/	kRandnumAuth				= 3,							/*	'Randnum Exchange' UAM */	k2WayRandnumAuth			= 6,							/*	'2-Way Randnum exchange'*/	kEncryptPassXport			= 7,							/*  'DHXCAST128' UAM (Diffie Hellman password transport)*/	kMinCustomUAM				= 128							/*	Minimum type value for a Custom UAM*/};struct GetVolSessInfoPB {	QElemPtr 						qLink;						/*  -  standard header stuff*/	short 							qType;						/*  -  standard header stuff*/	short 							ioTrap;						/*  -  standard header stuff*/	Ptr 							ioCmdAddr;					/*  -  standard header stuff*/	IOCompletionUPP 				ioCompletion;				/* <-  completion rtn pointer*/	OSErr 							ioResult;					/*  -> result from Async call*/	StringPtr 						ioNamePtr;					/*  -  standard header stuff*/	short 							ioVRefNum;					/*  -  standard header stuff*/	short 							ioRefNum;					/* <-  RefNum of the ".AFPTranslator"*/	short 							csCode;						/* <-  allways afpSVolInfo*/	Ptr 							vcbPtr;						/* <-  pointer to the VCB that you want info about*/	GetVolSessInfoRecPtr 			sessInfoBuffer;				/* <-  pointer to the GetVolSessInfoRec to be filled*/	long 							sessInfoSize;				/* <-  size of the GetVolSessInfoRec*/	long 							actSessInfoSize;			/*  -> actual size of the data returned*/};typedef struct GetVolSessInfoPB			GetVolSessInfoPB;typedef GetVolSessInfoPB *				GetVolSessInfoPBPtr;/* the AFPInsSessMemBlk & AFPRemSessMemBlk  calls are currently  required   when opening or closing a session. Make the AFPInsSessMemBlk call after the dsOpenSession   call succeeds (or returns afpAuthContinue), with the same dsOSSessionBlock that you   sent into dsOpenSession. You need to call AFPRemSessMemBlk with that same pointer after   calling dsCloseSession or dsCloseAll. */struct AFPInsRemSMBParam {	QElemPtr 						qLink;						/*  -  standard header stuff	*/	short 							qType;						/*  -  standard header stuff	*/	short 							ioTrap;						/*  -  standard header stuff	*/	Ptr 							ioCmdAddr;					/*  -  standard header stuff	*/	IOCompletionUPP 				ioCompletion;				/* <-  completion rtn pointer	*/	OSErr 							ioResult;					/*  -> result from Async call	*/	StringPtr 						ioNamePtr;					/*  -  standard header stuff	*/	short 							ioVRefNum;					/*  -  standard header stuff	*/	short 							ioRefNum;					/* <-  RefNum of the ".AFPTranslator"			*/	short 							csCode;						/* <-  AFPInsSessMemBlk or AFPRemSessMemBlk 	*/	Ptr 							smbPtr;						/* <-> pointer to the SMB to insert or remove	*/};typedef struct AFPInsRemSMBParam		AFPInsRemSMBParam;typedef AFPInsRemSMBParam *				AFPInsRemSMBPBPtr;/* Server Info Buffer returned from the dsGetStatus call 	*//* you should make your buffer at least 1024 bytes in size.	*//* a partial definition of the AFPSrvrInfo data structure (the fixed portion) */struct AFPSrvrInfo {	short 							fMachineOffset;	short 							fVerCountOffset;	short 							fUAMCountOffset;	short 							fIconOffset;	short 							fFlags;	unsigned char 					fSrvrName[2];};typedef struct AFPSrvrInfo				AFPSrvrInfo;/* definitions for the fFlags word	*/enum {	srvSCopyFile				= 0,							/* Server supports FPCopyFile call*/	srvSChangePswd				= 1,							/* Server supports FPChangePassword call*/	srvNoPswdSave				= 2,							/* Workstation should not save password*/	srvSServerMsgs				= 3,							/* Server supports server messages*/	srvSSrvrSig					= 4,							/* Server supports Server Signatures  (AFP 2.2)*/	srvSupportsTCP				= 5,							/* Server may be connected to via TCP/IP (AFP 2.2)*/	srvSNotification			= 6								/* Server will send notifications (AFP 2.2)*/};#if TARGET_CPU_68K																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandSync(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandSync(DSParamBlockPtr paramBlock)								ONEWORDINLINE(0xA004);																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandAsync(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandAsync(DSParamBlockPtr paramBlock)							ONEWORDINLINE(0xA404);/* use only for dsCloseAll	*/																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandImmediate(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandImmediate(DSParamBlockPtr paramBlock)						ONEWORDINLINE(0xA204);#else#define	NAFPCommandSync(dspb)	PBControlSync((ParmBlkPtr)(dspb)#define	NAFPCommandAsync(dspb)	PBControlAsync((ParmBlkPtr)(dspb)#define	NAFPCommandImmediate(dspb)	PBControlImmed((ParmBlkPtr)(dspb)#endif  /* TARGET_CPU_68K */#if PRAGMA_STRUCT_ALIGN	#pragma options align=reset#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(pop)#elif PRAGMA_STRUCT_PACK	#pragma pack()#endif#ifdef PRAGMA_IMPORT_OFF#pragma import off#elif PRAGMA_IMPORT#pragma import reset#endif#ifdef __cplusplus}#endif#endif /* __AFPDATASTREAM__ */